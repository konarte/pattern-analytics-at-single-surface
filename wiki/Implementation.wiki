#summary 2. Архитектура решения

<wiki:toc/>

== Введение ==
Предлагается выбрать средством решения язык Java 1.5, с использованием стандартного способа подключения к базам данных (JDBC). Java 1.5. Данное решение позволит использовать программу как в среде Windows, так и в среде Linux (и любой другой, которая позволит запустить виртуальную машину Java 1.5 и выше).

В качестве БД можно будет использовать любую СУБД. Мы будем использовать СУБД MySQL версии 5.x ([http://www.mysql.ru/download/ 5.1.28]). Данное решение позволит использовать единое хранилище данных для множества операторов данной системы. Нам нельзя забыть также о разграничении прав пользователей на просмотр и изменение данных. Предлагается реализовать классическую схему с защитой ролями необходимых элементов интерфейса и данных.

Предварительные фильтры изображения должны настраиваться в виде подключаемых модулей обработки – пользователь должен сам указать, в каком порядке и с какими параметрами эти фильтры будут применяться.

Как вы помните, нам необходимо иметь 5 видов данных – датчики, дефекты, материалы, поверхности и графики дефектов на определенных датчиках. В случае отсутствия дефекта будет фиксироваться сигнал от бездефектной поверхности.

== 2.1 Подсистема безопасности ==
Задача подсистемы безопасности – разграничить пользователей по виду выполняемых действий. Т.к. у нас достаточно простое приложение, то предлагается ввести жестко заданные классы + жестко заданные роли.
	В системе вводится три типа пользователей:
  * Администраторы системы (они могут добавлять модули, фильтры, датчики, дефекты, поверхности, управлять безопасностью, заносить новых пользователей и т.д., и т.п.)
  * Пользователи системы (они добавляют и изменяют годографы). В текущей реализации персонализация данных не требуется. В дальнейшем она должна быть решена на уровне БД (вместо копания с view-представлениями, хранимыми процедурами и т.д. предлагается просто нормально проработать слой обращения к базам данных, т.е. закодировать новое поведение схем безопасности должно быть элементарно). 
  * Гости системы. Они работают в режиме только просмотра.

Предлагается хранить каждого пользователя системы на уровне базы данных. Т.е. логины и пароли хранить не в приложении, а в БД.

@todo: Описать таблицы для хранение безопасности…

== 2.2 Описание таблиц ==

http://pattern-analytics-at-single-surface.googlecode.com/svn/wiki/model-report/images/edumgupipassdb.png

См. http://code.google.com/p/pattern-analytics-at-single-surface/source/browse/#svn/wiki/model-report


_Надо не забыть, чтобы последняя введенная цифра запоминалась, когда много вводишь всего._

=== 2.2 Датчики ===
@todo: Описать таблицы для датчиков...

_Далее геометрия датчика относительно дефекта (это пиздец из-за разной геометрии может быть разная картинка одного и тогоже дефекта но впрочем похуй):_

_Угол наклона в градусах от 0 до 45, может и 90 как частный случай перпендикулярного датчика положенного на бок._

_Зазор между датчиком и поверхностью контроля в миллиметрах от 0,1 до 2 – больше никакого отклика не получим._

_Сдвиг датчика относительно дефекта как мерить хз – предполагаю по максимуму искажения первоначального сигнала. В общем надо в резерв по умолчанию 0, в мм_


*Q: Геометрия относительно дефекта -- она относится к датчику или всё-таки к годографу, т.е. конкретному анализу дефекта данным датчиком?*

*Q: Имеет ли смысл хранить каталог магнитопроводов, ссылка на который будет вставляться в датчик?*

*Q: Имеет ли смысл хранить единый каталог материалов, для датчиков и для поверхностей?*

*Q: Имеет ли смысл хранить каталог катушек, ссылка на который будет вставляться в датчик?*

=== 2.3 Поверхности ===
*Q: Тут я запамятовал что к чему (может просто писать труба ХГк10 или плита Сталь45-01).*