#summary 3. Архитектура программного продукта

<wiki:toc/>

== 3.1 Общий вид ==
Программный продукт будет построен на модульной архитектуре, самое главное в ней – возможность подключения необходимых фильтров перед анализом изображения плюс выбор необходимого модуля анализа.

http://pattern-analytics-at-single-surface.googlecode.com/svn/wiki/doc/common-arch.gif


В текущем виде мы будем подгружать изображения из файлов. Собственно, источник изображения тоже будет выполнен в модульном виде – в зависимости от типа модуля, данные будут поступать по-разному.

== 3.2 Поддержка фильтров ==
Фильтр – это класс, реализующий специальный интерфейс. Фильтр может быть написан как на Java, так и на любом языке, который позволит создать динамическую библиотеку (DLL в Windows, Obj в Linux). В задачу фильтров входит: сглаживание изображения, борьба с шумами, увеличение резкости, построение вспомогательных данных на основе анализа изображения и т.д.

Каждый фильтр должен выполнять отдельное действие и иметь набор параметров, которые могут для него меняться.

Получение и установка параметров будет применять с помощью простого интерфейса обмена и формата JSON, т.е. фильтр отдельным методом возвращает список параметров, которые могут быть установлены, тип этих параметров, ограничения границ, значения по-умолчанию, а при установке эти значения будут переданы фильтр вместе с изображением.

На текущем этапе мы не будем заморачиваться с установкой специальных классов параметров (например, «область применения фильтра на изображении»).
Ожидается более подробный расписанный формат обмена.


=== 3.2.1 Пример хранения параметров фильтра ===
Фильтр имеет параметр «радиус округления» и задается в границах от 1 до 10 пикселей, а также параметр «Метод сглаживания», который выбирается из списка. В методе фильтра «Получить список параметров» мы должны вернуть следующую строку:

{{{
 {
  {
   “name”:”Радиус округления”, 
   “type”: “px”, 
   “default”: “2”,
   “low_border”: “1”, 
   “up_border”: “10”
  }, 
  {
   “name”:”Метод сглаживания”, 
   “type”:”list”, 
   “default”: “Простой”,
   “values”:[“Бикубический”, “Простой”]
  }
 }
}}}

Это JSON-формат. Он позволяет не зависеть от параметров фильтра, единожды задав формат, допустимые типы параметров и допустимые опции параметра (и делать любое количество параметров любого допустимого вида).

В метод непосредственного применения фильтра будет передана ссылка на canvas изображения + параметры в виде:
{{{
 {{“name”: “Радиус округления”,“value”: “4”},{“name”: “Метод сглаживания”,“value”: “Бикубический”}}
}}}

Ровно эта же строка будет помещена в поле *Options* таблицы *!LocusFilterOptions*. Это позволит хранить и обрабатывать параметры фильтров единым способом (как в случае работы в интерфейсе, так и при загрузке данных из базы для повторного применения фильтров с измененными параметрами). В случае повторной загрузки и открытии в интерфейсе, значение *value* будет подставлено вместо значения *default* для данного параметра.

== 3.3 Модули анализа изображения ==

Модуль анализа занимается тем, что сравнивает существующее изображение с уже сохраненными в базе данных.

Принцип работы прост – мы будем хранить как базовое изображение (с фильтрами и отмасштабированное), так и специально подготовленное для конкретного вида модуля анализа. При попытке сравнить текущий годограф с уже существующими, данный модуль анализа сначала будет пытаться получить нужный ему параметр из таблицы *!LocusModuleParams* (для существующего годографа в БД), а если его не найдет – он возьмет его оригинальное изображение и сконвертирует в нужную ему форму для сравнения.

Т.е. для годографов, занесенных в БД одинаковым модулем, сравнение будет производиться быстро, но в том числе это позволит сравнивать графики, занесенные разными модулями анализа.

Например, для модуля матричного анализа мы будем хранить в таблице *!LocusModuleParams* параметр с именем *MATRIX*. Содержать он будет матрицу изображения (уже отмасштабированного, с примененными фильтрами.) в удобном для вычисления формате. Размер картинки должен составлять 1024x1024 пикселей. Предлагается хранить изображение в виде плоского массива байтов (т.е. для картинки это будет ровно 1 мегабайтный массив; в случае затруднения с местом мы либо можем уменьшать её, либо применять ZIP-сжатие). Представление его в виде матрицы не составит труда (мы точно знаем длину одной строки матрицы). 

Следует помнить, что изображение может быть проанализировано разными модулями (последовательно), но загружено только одним подходящим.

Следует рассмотреть возможность создания хэша по каждому изображению или каждому случаю (включать в хэш датчик, поверхность, дефект и данные годографа). Можно оставить под это некий граф в БД. Для этого необходимо четко выделить критерии совпадения для компонентов, включаемых в хэш, а также указать условия, при которых эти совпадения выполняются. Быть может, если из годографа можно выделить дополнительную информацию, мы можем ограничиться просто условиями отбора в SQL-запросе?

Ввод параметров изображения может вестись параллельно с просмотром изображения. Во время ввода параметров пользователь выбирает дефект, датчик и поверхность которые будут привязаны к годографу (годограф в отрыве от вышеозначенных вещей быть не может).


== 3.4 Архитектура данных ==


http://pattern-analytics-at-single-surface.googlecode.com/svn/wiki/model-report/images/edumgupipassdb.png

См. http://code.google.com/p/pattern-analytics-at-single-surface/source/browse/#svn/wiki/model-report